.TH "couche1.h" 3 "Mon Apr 1 2019" "PROJET_S4" \" -*- nroff -*-
.ad l
.nh
.SH NAME
couche1.h
.SH SYNOPSIS
.br
.PP
\fC#include 'raid_defines\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBadd_finChemin\fP (const char *repertoire, char *nomDisque, size_t lengthRep)"
.br
.RI "Copie la chaine 'repertoire' dans nomDisque en y ajoutant '/d0\\0'\&. "
.ti -1c
.RI "void \fBinit_disk_raid5\fP (const char *repertoire, \fBvirtual_disk_t\fP *\fBr5Disk\fP)"
.br
.RI "Initialise la variable globale r5Disk\&. "
.ti -1c
.RI "void \fBturn_off_disk_raid5\fP (\fBvirtual_disk_t\fP *\fBr5Disk\fP)"
.br
.RI "Ferme les fichiers ouverts et sauvegarde le super block? "
.ti -1c
.RI "void \fBinfo_disque\fP (\fBvirtual_disk_t\fP *\fBr5Disk\fP)"
.br
.RI "Affiche des infos sur les disques ouverts\&. "
.ti -1c
.RI "int \fBcompute_nblock\fP (int n)"
.br
.RI "calcule le nombre de blocs pour coder 'n' octets "
.ti -1c
.RI "void \fBwrite_block\fP (\fBvirtual_disk_t\fP *RAID5, \fBblock_t\fP *entrant, \fBuint\fP pos, int idDisk)"
.br
.RI "Ecrit un bloc à la position pos sur le disque\&. "
.ti -1c
.RI "int \fBread_block\fP (\fBvirtual_disk_t\fP *RAID5, \fBblock_t\fP *recup, \fBuint\fP pos, int idDisk)"
.br
.RI "Lit un bloc à la position pos sur le disque\&. "
.ti -1c
.RI "void \fBblock_repair\fP (\fBvirtual_disk_t\fP *RAID5, \fBuint\fP pos, int idDisk)"
.br
.ti -1c
.RI "void \fBoctetsToHexa\fP (\fBblock_t\fP monBloc, char *nbHexa)"
.br
.RI "prend un tableau de 4 octets (char) et le transforme en Hexadecimal assert(monBloc[i]<256); "
.ti -1c
.RI "int \fBaffichageBlockHexa\fP (\fBvirtual_disk_t\fP *RAID5, int idDisk, \fBuint\fP pos, FILE *output)"
.br
.RI "affiche un bloc de donnees en hexadecimal "
.ti -1c
.RI "int \fBaffichageBlockDecimal\fP (\fBvirtual_disk_t\fP *RAID5, int idDisk, \fBuint\fP pos, FILE *output)"
.br
.ti -1c
.RI "char \fBconversionHexa\fP (char nb4bits)"
.br
.RI "transforme un nombre en son chiffre en hexa "
.ti -1c
.RI "void \fBxorbl\fP (\fBblock_t\fP *xa, \fBblock_t\fP *xb, \fBblock_t\fP *destination)"
.br
.ti -1c
.RI "int \fBcouche1\fP (void)"
.br
.ti -1c
.RI "void \fBaffichageDisque\fP (\fBvirtual_disk_t\fP *RAID5, int idDisk, FILE *output)"
.br
.ti -1c
.RI "int \fBconversionDec\fP (int nb4bits)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void add_finChemin (const char * repertoire, char * nomDisque, size_t lengthRep)"

.PP
Copie la chaine 'repertoire' dans nomDisque en y ajoutant '/d0\\0'\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP chaine de char (repertoire) 
.br
\fI\fP chaine de char (disk) 
.br
\fI\fP size_t 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.PP
Definition at line 29 of file couche1\&.c\&.
.SS "int affichageBlockDecimal (\fBvirtual_disk_t\fP * RAID5, int idDisk, \fBuint\fP pos, FILE * output)"

.PP
Definition at line 291 of file couche1\&.c\&.
.SS "int affichageBlockHexa (\fBvirtual_disk_t\fP * RAID5, int idDisk, \fBuint\fP pos, FILE * output)"

.PP
affiche un bloc de donnees en hexadecimal 
.PP
\fBParameters:\fP
.RS 4
\fI\fP virtual_disk_t 
.br
\fI\fP integer (n° disk) 
.br
\fI\fP integer (posit° de ce qu'on veut afficher) 
.RE
.PP
\fBReturns:\fP
.RS 4
: void 
.RE
.PP

.PP
Definition at line 274 of file couche1\&.c\&.
.SS "void affichageDisque (\fBvirtual_disk_t\fP * RAID5, int idDisk, FILE * output)"

.PP
Definition at line 311 of file couche1\&.c\&.
.SS "void block_repair (\fBvirtual_disk_t\fP * RAID5, \fBuint\fP pos, int idDisk)"

.PP
Definition at line 163 of file couche1\&.c\&.
.SS "int compute_nblock (int n)"

.PP
calcule le nombre de blocs pour coder 'n' octets 
.PP
\fBParameters:\fP
.RS 4
\fIinteger\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
integer 
.RE
.PP

.PP
Definition at line 93 of file couche1\&.c\&.
.SS "int conversionDec (int nb4bits)"

.PP
Definition at line 226 of file couche1\&.c\&.
.SS "char conversionHexa (char nb4bits)"

.PP
transforme un nombre en son chiffre en hexa 
.PP
\fBParameters:\fP
.RS 4
\fI\fP nb4bits, la valeur de 4 bits en entier 
.RE
.PP
\fBReturns:\fP
.RS 4
: le chiffre en hexadecimal 
.RE
.PP

.PP
Definition at line 207 of file couche1\&.c\&.
.SS "int couche1 (void)"

.PP
Definition at line 319 of file couche1\&.c\&.
.SS "void info_disque (\fBvirtual_disk_t\fP * r5Disk)"

.PP
Affiche des infos sur les disques ouverts\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP virtual_disk_t 
.RE
.PP
\fBReturns:\fP
.RS 4
: void 
.RE
.PP

.PP
Definition at line 79 of file couche1\&.c\&.
.SS "void init_disk_raid5 (const char * repertoire, \fBvirtual_disk_t\fP * r5Disk)"

.PP
Initialise la variable globale r5Disk\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fP chaine de char (repertoire cible) 
.br
\fI\fP virtual_disk_t 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.PP
Definition at line 44 of file couche1\&.c\&.
.SS "void octetsToHexa (\fBblock_t\fP monBloc, char * nbHexa)"

.PP
prend un tableau de 4 octets (char) et le transforme en Hexadecimal assert(monBloc[i]<256); 
.PP
\fBParameters:\fP
.RS 4
\fI\fP block_t (Contient le tableau de bits) 
.br
\fI\fP char* (Caractere dans lequel on met l'hexa) 
.RE
.PP
\fBReturns:\fP
.RS 4
: void 
.RE
.PP

.PP
Definition at line 192 of file couche1\&.c\&.
.SS "int read_block (\fBvirtual_disk_t\fP * RAID5, \fBblock_t\fP * recup, \fBuint\fP pos, int idDisk)"

.PP
Lit un bloc à la position pos sur le disque\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvirtual_disk_t\fP 
.br
\fIblock_t\fP (à lire) 
.br
\fIuint\fP (position à laquelle on lit) 
.br
\fIinteger\fP (n° disk) 
.RE
.PP
\fBReturns:\fP
.RS 4
integer 
.RE
.PP

.PP
Definition at line 130 of file couche1\&.c\&.
.SS "void turn_off_disk_raid5 (\fBvirtual_disk_t\fP * r5Disk)"

.PP
Ferme les fichiers ouverts et sauvegarde le super block? 
.PP
\fBParameters:\fP
.RS 4
\fI\fP chaine de char (repertoire cible) 
.br
\fI\fP virtual_disk_t 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.PP
Definition at line 66 of file couche1\&.c\&.
.SS "void write_block (\fBvirtual_disk_t\fP * RAID5, \fBblock_t\fP * entrant, \fBuint\fP pos, int idDisk)"

.PP
Ecrit un bloc à la position pos sur le disque\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvirtual_disk_t\fP 
.br
\fIblock_t\fP (à ecrire) 
.br
\fIuint\fP (position à laquelle on ecrit) 
.br
\fIinteger\fP (n° disk) 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.PP
Definition at line 112 of file couche1\&.c\&.
.SS "void xorbl (\fBblock_t\fP * xa, \fBblock_t\fP * xb, \fBblock_t\fP * destination)"

.PP
Definition at line 141 of file couche1\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for PROJET_S4 from the source code\&.
